
ğŸ“˜ EXPLICACIÃ“N DE ENEMYCONTROLLER

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¾ FUNCIÃ“N PRINCIPAL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
El script **EnemyController** controla el comportamiento de cada enemigo individual.  
Su objetivo es **seguir al jugador**, **atacarlo** y **aplicar daÃ±o y retroceso (knockback)** cuando hay colisiÃ³n.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš™ï¸ VARIABLES PRINCIPALES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- rB: componente Rigidbody2D, necesario para mover al enemigo mediante fÃ­sicas.
- anim: referencia al Animator del enemigo para controlar sus animaciones.
- moveSpeed: velocidad de movimiento del enemigo.
- damageAmount: cantidad de daÃ±o que inflige al jugador al tocarlo.
- hitWaitTime: tiempo de espera entre cada golpe (evita daÃ±o constante).
- hitCounter: contador para medir ese tiempo de espera.
- knockbackForce: fuerza con la que empuja al jugador al golpearlo.
- target: referencia al transform del jugador (su posiciÃ³n en el mundo).
- healthController: referencia al script PlayerHealthController para aplicar daÃ±o.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš€ INICIO DEL ENEMIGO (Start)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Se obtienen los componentes Rigidbody2D y Animator del enemigo.
2. Busca al jugador por su etiqueta â€œPlayerâ€.
3. Guarda la posiciÃ³n (Transform) y su componente de salud (PlayerHealthController).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸƒ MOVIMIENTO Y LÃ“GICA (FixedUpdate)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cada frame de fÃ­sica (FixedUpdate) hace lo siguiente:

1. **Verifica que el jugador exista y estÃ© vivo.**
   - Si el jugador estÃ¡ vivo, el enemigo lo sigue.
   - Si el jugador estÃ¡ muerto, el enemigo se detiene y su animaciÃ³n se congela.

2. **Movimiento hacia el jugador:**
   - Calcula la direcciÃ³n hacia el jugador con `(target.position - transform.position).normalized`.
   - Multiplica por la velocidad (`moveSpeed`) para generar la velocidad del Rigidbody.

3. **OrientaciÃ³n del sprite:**
   - Invierte el eje X del sprite para que siempre mire hacia el jugador.

4. **Control del contador de golpe (hitCounter):**
   - Si el contador es mayor que 0, lo reduce con el tiempo hasta permitir el siguiente golpe.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ’¥ COLISIÃ“N Y DAÃ‘O (OnCollisionStay2D)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cuando el enemigo **permanece en contacto** con el jugador:

1. Verifica si el objeto tiene la etiqueta â€œPlayerâ€.
2. Comprueba que el contador `hitCounter` estÃ© en 0 (es decir, que pueda volver a golpear).
3. Si el jugador estÃ¡ vivo:
   - Llama a `TakeDamage(damageAmount)` del PlayerHealthController.
   - Obtiene el Rigidbody2D del jugador para aplicar un **knockback** (empuje hacia atrÃ¡s).
   - Calcula la direcciÃ³n del empuje y aplica una fuerza instantÃ¡nea (`ForceMode2D.Impulse`).
4. Reinicia el `hitCounter` con el valor de `hitWaitTime` para esperar antes del siguiente golpe.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  EN RESUMEN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- El enemigo **persigue constantemente al jugador** mientras estÃ© vivo.
- Cuando colisiona, le **hace daÃ±o y lo empuja** hacia atrÃ¡s.
- Usa un **temporizador de ataque** (`hitCounter`) para evitar golpear continuamente.
- Si el jugador muere, el enemigo se **detiene por completo**.

En conjunto con **EnemySpawner** y **ObjectPooler**, este script forma la parte dinÃ¡mica del sistema de enemigos:
- **ObjectPooler** gestiona su creaciÃ³n y rendimiento.
- **EnemySpawner** controla cuÃ¡ndo y dÃ³nde aparecen.
- **EnemyController** define cÃ³mo se comportan en el juego.
